{
    "sourceFile": "modules/algorithm/puzzle_15_bfs.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1749981234284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1749981248050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,59 @@\n+class State:\r\n+    def __init__(self, initial_state):\r\n+        self.initial_state = tuple(initial_state)\r\n+        \r\n+    def generate_neighbours(self):\r\n+        first_state = self.initial_state\r\n+        neighbour = []\r\n+\r\n+        moves = {\r\n+            'up':-3,\r\n+            'down':+3,\r\n+            'left':-1,\r\n+            'right':+1\r\n+        }\r\n+        invalid_left = [0,3,6]\r\n+        invalid_right = [2,5,8]\r\n+\r\n+        #finding the first instance of 0\r\n+        index = first_state.index(0)\r\n+\r\n+\r\n+        for direction, v in moves.items():\r\n+            new_index = index + v\r\n+            if direction == 'left' and index in invalid_left:\r\n+                continue\r\n+            if direction == 'right' and index in invalid_right:\r\n+                continue\r\n+            if 0 <= new_index < 9:\r\n+                new_initial_state = first_state[:]\r\n+                new_initial_state[index],new_initial_state[new_index] =  new_initial_state[new_index], new_initial_state[index]\r\n+                neighbour.append(new_initial_state)\r\n+        return neighbour\r\n+\r\n+    def breadth_first_search(self,initial_state,goal_state):\r\n+\r\n+        queue = [] # or could be a deque\r\n+        queue.append(initial_state)\r\n+        visited_states = set()\r\n+        visited_states.add(tuple(initial_state))\r\n+        steps = {}  # To track the different states\r\n+\r\n+        while len(queue) > 0:\r\n+            current_state = queue.pop(0)\r\n+            if current_state == goal_state:\r\n+                print(f'The puzzule has been sovle. {current_state}')\r\n+                return current_state\r\n+            \r\n+            current = State(current_state)\r\n+            neighbors = current.generate_neighbours()\r\n+            for n in neighbors:\r\n+                    if tuple(n) not in visited_states:\r\n+                        \r\n+                        visited_states.add(tuple(n))\r\n+                        queue.append(n)\r\n+            \r\n+        print(f'Puzzle not solvable')\r\n+        return initial_state\r\n+    \r\n+    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749981806788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n                 new_initial_state[index],new_initial_state[new_index] =  new_initial_state[new_index], new_initial_state[index]\r\n                 neighbour.append(new_initial_state)\r\n         return neighbour\r\n \r\n-    def breadth_first_search(self,initial_state,goal_state):\r\n+    def breadth_first_search(self,goal_state):\r\n \r\n         queue = [] # or could be a deque\r\n         queue.append(initial_state)\r\n         visited_states = set()\r\n"
                },
                {
                    "date": 1749981818916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,59 @@\n+class State:\r\n+    def __init__(self, initial_state):\r\n+        self.initial_state = tuple(initial_state)\r\n+        \r\n+    def generate_neighbours(self):\r\n+        first_state = self.initial_state\r\n+        neighbour = []\r\n+\r\n+        moves = {\r\n+            'up':-3,\r\n+            'down':+3,\r\n+            'left':-1,\r\n+            'right':+1\r\n+        }\r\n+        invalid_left = [0,3,6]\r\n+        invalid_right = [2,5,8]\r\n+\r\n+        #finding the first instance of 0\r\n+        index = first_state.index(0)\r\n+\r\n+\r\n+        for direction, v in moves.items():\r\n+            new_index = index + v\r\n+            if direction == 'left' and index in invalid_left:\r\n+                continue\r\n+            if direction == 'right' and index in invalid_right:\r\n+                continue\r\n+            if 0 <= new_index < 9:\r\n+                new_initial_state = first_state[:]\r\n+                new_initial_state[index],new_initial_state[new_index] =  new_initial_state[new_index], new_initial_state[index]\r\n+                neighbour.append(new_initial_state)\r\n+        return neighbour\r\n+\r\n+    def breadth_first_search(self,goal_state):\r\n+\r\n+        queue = [] # or could be a deque\r\n+        queue.append(selfinitial_state)\r\n+        visited_states = set()\r\n+        visited_states.add(tuple(initial_state))\r\n+        steps = {}  # To track the different states\r\n+\r\n+        while len(queue) > 0:\r\n+            current_state = queue.pop(0)\r\n+            if current_state == goal_state:\r\n+                print(f'The puzzule has been sovle. {current_state}')\r\n+                return current_state\r\n+            \r\n+            current = State(current_state)\r\n+            neighbors = current.generate_neighbours()\r\n+            for n in neighbors:\r\n+                    if tuple(n) not in visited_states:\r\n+                        \r\n+                        visited_states.add(tuple(n))\r\n+                        queue.append(n)\r\n+            \r\n+        print(f'Puzzle not solvable')\r\n+        return initial_state\r\n+    \r\n+    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749981833232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n \r\n         queue = [] # or could be a deque\r\n         queue.append(self.initial_state)\r\n         visited_states = set()\r\n-        visited_states.add(tuple(initial_state))\r\n+        visited_states.add(tuple(self.initial_state))\r\n         steps = {}  # To track the different states\r\n \r\n         while len(queue) > 0:\r\n             current_state = queue.pop(0)\r\n"
                },
                {
                    "date": 1749981839565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,59 @@\n+class State:\r\n+    def __init__(self, initial_state):\r\n+        self.initial_state = tuple(initial_state)\r\n+        \r\n+    def generate_neighbours(self):\r\n+        first_state = self.initial_state\r\n+        neighbour = []\r\n+\r\n+        moves = {\r\n+            'up':-3,\r\n+            'down':+3,\r\n+            'left':-1,\r\n+            'right':+1\r\n+        }\r\n+        invalid_left = [0,3,6]\r\n+        invalid_right = [2,5,8]\r\n+\r\n+        #finding the first instance of 0\r\n+        index = first_state.index(0)\r\n+\r\n+\r\n+        for direction, v in moves.items():\r\n+            new_index = index + v\r\n+            if direction == 'left' and index in invalid_left:\r\n+                continue\r\n+            if direction == 'right' and index in invalid_right:\r\n+                continue\r\n+            if 0 <= new_index < 9:\r\n+                new_initial_state = first_state[:]\r\n+                new_initial_state[index],new_initial_state[new_index] =  new_initial_state[new_index], new_initial_state[index]\r\n+                neighbour.append(new_initial_state)\r\n+        return neighbour\r\n+\r\n+    def breadth_first_search(self,goal_state):\r\n+\r\n+        queue = [] # or could be a deque\r\n+        queue.append(self.initial_state)\r\n+        visited_states = set()\r\n+        visited_states.add(tuple(self.initial_state)\r\n+        steps = {}  # To track the different states\r\n+\r\n+        while len(queue) > 0:\r\n+            current_state = queue.pop(0)\r\n+            if current_state == goal_state:\r\n+                print(f'The puzzule has been sovle. {current_state}')\r\n+                return current_state\r\n+            \r\n+            current = State(current_state)\r\n+            neighbors = current.generate_neighbours()\r\n+            for n in neighbors:\r\n+                    if tuple(n) not in visited_states:\r\n+                        \r\n+                        visited_states.add(tuple(n))\r\n+                        queue.append(n)\r\n+            \r\n+        print(f'Puzzle not solvable')\r\n+        return initial_state\r\n+    \r\n+    \n\\ No newline at end of file\n"
                }
            ],
            "date": 1749981234284,
            "name": "Commit-0",
            "content": "class State:\r\n    def __init__(self, initial_state):\r\n        self.initial_state = tupleinitial_state\r\n        \r\n    def generate_neighbours(self):\r\n        first_state = self.initial_state\r\n        neighbour = []\r\n\r\n        moves = {\r\n            'up':-3,\r\n            'down':+3,\r\n            'left':-1,\r\n            'right':+1\r\n        }\r\n        invalid_left = [0,3,6]\r\n        invalid_right = [2,5,8]\r\n\r\n        #finding the first instance of 0\r\n        index = first_state.index(0)\r\n\r\n\r\n        for direction, v in moves.items():\r\n            new_index = index + v\r\n            if direction == 'left' and index in invalid_left:\r\n                continue\r\n            if direction == 'right' and index in invalid_right:\r\n                continue\r\n            if 0 <= new_index < 9:\r\n                new_initial_state = first_state[:]\r\n                new_initial_state[index],new_initial_state[new_index] =  new_initial_state[new_index], new_initial_state[index]\r\n                neighbour.append(new_initial_state)\r\n        return neighbour\r\n\r\n    def breadth_first_search(self,initial_state,goal_state):\r\n\r\n        queue = [] # or could be a deque\r\n        queue.append(initial_state)\r\n        visited_states = set()\r\n        visited_states.add(tuple(initial_state))\r\n        steps = {}  # To track the different states\r\n\r\n        while len(queue) > 0:\r\n            current_state = queue.pop(0)\r\n            if current_state == goal_state:\r\n                print(f'The puzzule has been sovle. {current_state}')\r\n                return current_state\r\n            \r\n            current = State(current_state)\r\n            neighbors = current.generate_neighbours()\r\n            for n in neighbors:\r\n                    if tuple(n) not in visited_states:\r\n                        \r\n                        visited_states.add(tuple(n))\r\n                        queue.append(n)\r\n            \r\n        print(f'Puzzle not solvable')\r\n        return initial_state\r\n    \r\n    "
        }
    ]
}