{
    "sourceFile": "modules/lists/bfs.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 27,
            "patches": [
                {
                    "date": 1749494766586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1749495083222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1 @@\n+''\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495101857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n"
                },
                {
                    "date": 1749495107484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+BFS\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495113231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+BFS()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495118831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495125424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495138392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495156041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495161883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    q\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495169027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    Q.enq\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495176649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495189371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s):\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495196854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,18 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495202465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,18 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while Q\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495208655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,18 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while Q is not \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495389377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,19 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while Q is not None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495399810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,19 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+from collections impor\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while Q is not None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495405575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,19 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+from collections import deque\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while Q is not None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495417841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,20 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+from collections import deque\r\n+\r\n+def BFS(G,s):\r\n+    Q.enqueue(s)\r\n+    while Q is not None\r\n+    de\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495525121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,14 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n"
                },
                {
                    "date": 1749495532724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+graph \n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495549860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+graph = {\r\n+    \r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495556788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+graph = {\r\n+    'A' \r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495562940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,364 +12,6 @@\n                if w is not visited \r\n                         Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n                         mark w as visited.'''\r\n graph = {\r\n-    'A' \r\n-}\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-graph = {\r\n-    \r\n-}\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-graph \n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-from collections import deque\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while Q is not None\r\n-    de\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-from collections import deque\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while Q is not None\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-from collections impor\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while Q is not None\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while Q is not None\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while Q is not \n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while Q\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\r\n-    while \n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s):\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    Q.enqueue(s)\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    Q.enq\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    q\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\r\n-    \n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS(G,s):\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def BFS()\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-def \n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-BFS()\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-BFS\n-'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n-      let Q be queue.\r\n-      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n-\r\n-      mark s as visited.\r\n-      while ( Q is not empty)\r\n-           //Removing that vertex from queue,whose neighbour will be visited now\r\n-           v  =  Q.dequeue( )\r\n-\r\n-          //processing all the neighbours of v  \r\n-          for all neighbours w of v in Graph G\r\n-               if w is not visited \r\n-                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n-                        mark w as visited.'''\r\n-\r\n-''\n\\ No newline at end of file\n+    'A': \r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495569055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,6 +12,6 @@\n                if w is not visited \r\n                         Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n                         mark w as visited.'''\r\n graph = {\r\n-    'A': \r\n+    'A': []\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495575522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,6 +12,6 @@\n                if w is not visited \r\n                         Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n                         mark w as visited.'''\r\n graph = {\r\n-    'A': ['']\r\n+    'A': ['B']\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1749495582127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+'''BFS (G, s)                   //Where G is the graph and s is the source node\r\n+      let Q be queue.\r\n+      Q.enqueue( s ) //Inserting s in queue until all its neighbour vertices are marked.\r\n+\r\n+      mark s as visited.\r\n+      while ( Q is not empty)\r\n+           //Removing that vertex from queue,whose neighbour will be visited now\r\n+           v  =  Q.dequeue( )\r\n+\r\n+          //processing all the neighbours of v  \r\n+          for all neighbours w of v in Graph G\r\n+               if w is not visited \r\n+                        Q.enqueue( w )             //Stores w in Q to further visit its neighbour\r\n+                        mark w as visited.'''\r\n+graph = {\r\n+    'A': ['B',[]]\r\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1749494766586,
            "name": "Commit-0",
            "content": ""
        }
    ]
}